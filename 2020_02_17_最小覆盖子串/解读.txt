最小覆盖子串
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
说明：

如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。

建立一个窗口，两边的界限分别是left和right。开始时right在字符串s上向右移动，直到窗口[left,right]包含t中所有字符，记录下此时窗口长度，然后向右移动left，缩小窗口，直到窗口[left,right]不包含t中所有字符，记录下长度，然后再向右移动right。如此往复，直到right超出s的长度。
*此题的难点在于滑动窗口和当前的字符是否在t中的查询。如果每次查找字符s[i]都遍历t，那这个时间复杂度太高了（最差是O(s*t)）。一开始想的是建立一个未被访问字符的数组notFound（map<char,int>，第二个int是用来记录需要被包含几次，比如t="ABB"，那么B要访问两次），把t中没有被访问的字符放进去，然后另一个数组放已经被访问过的字符hasFound，每次只需要看notFound是否为空即可。但这样超时了。原因在于notFound和hasFound以及对于t中单个字符查找太慢。
改进是考虑字符都是ASCII码，所以每一个字符都相当于是数组的一个索引，建立vector<int> notFound(128,0），这样可以直接使用notFound[s[i]]来查询是否在t中，然后用逆向减法思维，被访问不是+1，而是-1，开始时初始化notFound，在t中出现字符，都加一，notFound[t[i]]++。在遍历时，如果在窗口中被包含了，就减一，notFound[s[i]]--，从窗口中出来时，再加一。并维护一个count来判定t中的字符是否都被包含（count的初始值为t.length()，count==0时表示t中的所有字符都被包含了）
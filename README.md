# LeetCode
刷题

## 提交代码
git add . <br/>
git commit -m "注释语句" <br/>
git pull origin master  <br/>
git push origin master  <br/>


### 摆动排序 II（参考网上代码）
- 题目：
给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序 <br/>
- 难点：
用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现 <br/>
- 解题思路：
首先找出数组的中位数mid。然后将小于mid的数放在数组的偶数位置（0，2，4……），将大于mid的数放在数组的奇数位置（1，3，5……） <br/> 


### 有序矩阵中第K小的元素（自己做的，有待优化）
- 题目：
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。 <br/>
- 难点：
速度太慢，算法有待优化 <br/>
- 解题思路：
这个算法是自己做的（所以才慢233），很简单，从矩阵的左上角开始遍历，将当前坐标（i，j）的右方和下方的数放入priority_queue中。下一次执行时，从priority_queue中取出最小的数，然后重复执行，直至第k个数 <br/> 

### 寻找两个有序数组的中位数（参考网上代码）
- 题目：
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 <br/>
- 难点：
这道题思考起来还是挺绕的，即使看了解析，在代码实现上还是有难度。 <br/>
- 解题思路：
大框架的思路采用二分法，对第K大的数进行二分。首先，对两个数组（暂且称为a、b）寻找第K/2大的数a_mid，b_mid，如果a_mid大于b_mid，那么第K大的数肯定不在b_mid前的数中，所以我们可以舍弃b的前K/2个数（相当于把B的指针向后移动K/2），然后K的值变为K-K/2，重复上述步骤。反之同理。<br/> 
这里要注意几个临界值的处理，首先是k=1的时候，就表示寻找第K大的数，所以只需要从当前a和b的第一个数中取最小的即可。其次是若a的当前索引超出了a的长度，那么说明第K大的数在b中，可以直接从B中求得，反之亦然。 <br/>

### 乘积最大子序列（参考网上代码）
- 题目：
给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 <br/>
- 难点：
好久没做动态规划的题了，今天一做有点手生，直接看了网上的代码 <br/>
- 解题思路：
看过解题思路后还是很简单的。用两个变量分别记录前一个数的最大数和最小数（因为存在负负得正的情况，所以要保存最小值），在遍历的时候让当前值分别和最大数和最小数相乘，并和当前值比较，选出选个数中的最大数和最小数，记录下新的最大值和最小值，并更新全局最大数 <br/> 

### Best Time to Buy and Sell Stock with Cooldown （参考网上代码）
- 题目：
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 .设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: <br/>
--- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br/>
--- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 <br/>
- 难点：
还是动态规划，感觉啥也不会了（越来越菜了） <br/>
- 解题思路：
从网上看到一个图，很清晰 <br/> 
